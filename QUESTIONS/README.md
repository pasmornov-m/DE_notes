# QUESTIONS

---

## **1. Хранилища данных (DWH, Data Lake, архитектура)**

* [Какие подходы построения хранилища данных тебе известны?](#подходы-построения-хранилища-данных)
* [Чем Data Lake отличается от DWH?](#чем-data-lake-отличается-от-dwh)
* [В чем разница подходов Кимболла и Инмона?](#разница-между-подходами-кимболла-и-инмона)
* [Расскажи, что знаешь про SCD?](#scd-slowly-changing-dimensions)
* [Как сформировать процесс SCD2 для вставки, изменения, удаления?](#как-реализовать-scd-type-2-на-примере-клиентов)
* [Как правильно работать с таблицами, если 1я — это просто справочник (например, пользователи) построенный по SCD2, а 2я — это покупки пользователей, и необходимо найти все покупки пользователя с актуальными данными на день покупки.](#как-правильно-работать-с-таблицами-если-1я--это-просто-справочник-например-пользователи-построенный-по-scd2-а-2я--это-покупки-пользователей-и-необходимо-найти-все-покупки-пользователя-с-актуальными-данными-на-день-покупки)
* [Расскажи какие слои есть в хранилище данных?](#слои-в-хранилище-данных)
* [Чем в хранилище ODS слой отличается от DDS слоя?](#слои-в-хранилище-данных)

---

## **2. HDFS, Hadoop, Spark, Hive, Oozie, YARN**

* Что такое HDFS? Из чего она состоит и как работает?
* Какие проблемы бывают с HDFS?
* Что такое перекос данных?
* Как работает HSFD? Для чего нужна NameNode, Secondary NameNode? Нам необходимо считать текстовый файл из HDFS, объясни, что будет происходить?
* Что такое фактор репликации в HDFS и для чего он нужен?
* Что такое Hadoop и из каких компонентов он состоит?
* Что такое YARN?
* Для чего нужен Apache Oozie?
* Что такое Hive и объясни, как он работает с данными?
* Что такое партиционирование и что оно из себя представляет в Hadoop?
* Что такое Spark? Для чего она нужна?
* Что делает Shuffle в Spark? Между чем передаются данные?
* Объясни парадигму MapReduce и почему Spark пришел ей на замену?
* Какие виды exchange (motion) в Spark?
* Как передать UDF?
* Расскажите про Job stage task в Spark.
* Что такое catalyst?

---

## **3. ClickHouse**

* Какие движки ClickHouse вы знаете?
* Какие особенности у движка ReplicatingMergeTree?
* Представь у тебя есть PGSQL и ClickHouse, как бы ты загружал данные из PGSQL в ClickHouse?
* Тебе необходимо из источника отправлять данные в нейронку каждые 10 минут, после чего результат записывать в ClickHouse, как ты это сделаешь? Опиши весь процесс.
* Как создать распределенную таблицу в Clickhouse?
* Какие движки в ClickHouse ты знаешь? И в чем их различия?
* Как оптимизировать запросы в Clickhouse?
* Как в Clickhouse устроена операция UPDATE?

---

## **4. Greenplum**

* В чем различие между GreenPlum и HDFS?
* Как происходит оптимизация запросов в GreenPlum?
* Для каких целей преднозначен Clickhouse и GreenPlum?

---

## **5. SQL, оконные функции, индексы, joins, СТЕ и др.**

* Что такое оконные функции?
* Как задать границы окна?
* В чем будет разница вывода, если я напишу агрегирующую оконную функцию по сумме с сортировкой и без неё?
* Чем отличаются оконные функции от агрегирующих в SQL?
* Можно ли использовать несколько агрегационных функций в select?
* Представим что DENSE_RANK не существует, как сделать её функционал с помощью ROW_NUMBER?
* Чем отличается DENSE_RANK от RANK?
* Как RANK() работает с NULL?
* У вас есть поле с datetime,  а вам надо сделать фильтр по дате без учета времени - перечислите возможные способы решения проблемы.
* Перечислите логические и физические джойны и алгоритмическую сложность физических.
* Что делает утилита PGTune?
* Что такое нормализация?
* Какие типы индексов бывают?
* Чем отличается кластеризованный индекс от некластеризованного?
* Сколько у таблицы может быть кластеризованных индексов?
* Есть ли ограничения на создание партицированной таблицы?
* Можно ли строить индекс по JSON полям?
* Чем отличаются типы данных JSON и JSONb?
* Чем отличаются материализованное и нематериализованное представления?
* Можно ли читать данные из материализованного представления, когда выполняется команда REFRESH?
* Как удалить дубликаты из таблицы?
* Как эффективно удалить дубликаты строк в большой таблице?
* Какой объявить СТЕ? Можно ли в одной таблице применить несколько СТЕ?
* Что из себя представляет СТЕ?
* Как оптимизируется запрос?
* Что будет делать, если в плане запроса увидели Nested Loop?
* Чем колоночные БД отличаются от строковых?

---

## **6. PostgreSQL (PGSQL)**

* Как выдаются права доступа в PostgreSQL?
* Как устроена система транзакций в PSQL?
* Какие блокировки существуют?

---

## **7. Apache NiFi**

* Какие процессоры использовали в NiFi?
* Настраивали ли схемы, если да, то в каких модулях?
* Как считать данные из каталога?
* Зачем при считывании CSV файлов данные переводили в AVRO формат?
* В случае сбоя одного сервера с NiFi — как его перезапустить?
* Чем Атрибут отличается от Контекста?
* Теряет ли данные NiFi, если произошел сбой программы?
* Расскажи о логировании в NiFi?
* Какой модуль в NiFi используется для JOLT преобразований?
* NiFi работает в кластере и считываем данные из Kafka, один из серверов сгорает, и мы теряем данные. Как повторно обработать потерянные данные?

---

## **8. Apache Airflow**

* Таска в AirFlow упала с ошибкой, как сделать так, чтобы несмотря на ошибку, следующая таска запустилась?
* Как в AirFlow в зависимости от условия, продолжить обработку по нужной ветке ДАГа?
* Что такое Dataset в Airflow?
* Что представляет из себя Sensor в Airflow?
* Как передавать данные между задачами в Airflow? (ответа xcom не достаточно)

---

## **9. Python: функции, декораторы, ООП и др.**

* [Лямбда функция (что это, зачем, где использовать)](#лямбда-функция-что-это-зачем-где-использовать)
* [В чем разница "==" и "is"?](#в-чем-разница--и-is)
* [В чем разница между `func` и `func()`?](#в-чем-разница-между-func-и-func)
* [Назовите изменяемые и неизменяемые объекты (типы).](#назовите-изменяемые-и-неизменяемые-объекты-типы)
* [Декораторы (что, зачем нужно, как влияет на структуру) + написать свой пример](#декораторы-что-зачем-нужно-как-влияет-на-структуру--написать-свой-пример)
* [Можно ли на одну функцию нацепить несколько декораторов и как они будут считываться?](#можно-ли-на-одну-функцию-нацепить-несколько-декораторов-и-как-они-будут-считываться)
* [Что такое декоратор Шредингера?](#что-такое-декоратор-шредингера)
* [Генератор (что, зачем нужно) + написать свой пример](#генератор-что-зачем-нужно--написать-свой-пример)
* [Как рассчитывается сложность алгоритма? на примере list, tuple](#как-рассчитывается-сложность-алгоритма-на-примере-list-tuple)
* [Как передаются аргументы в функцию?](#как-передаются-аргументы-в-функцию)
* [Функция, которая используется в качестве аргумента, может использовать свои аргументы?](#функция-которая-используется-в-качестве-аргумента-может-использовать-свои-аргументы)
* [Зачем прописывать тип входящих или выходящих данных в функцию?](#зачем-прописывать-тип-входящих-или-выходящих-данных-в-функцию)
* [Какая типизация используется в Python?](#зачем-прописывать-тип-входящих-или-выходящих-данных-в-функцию)
* [Что представляет из себя тип данных Int в Python?](#что-представляет-из-себя-тип-данных-int-в-python)
* [Можно ли в функции Python в качестве аргумента использовать функцию? Если да, то как называется такая функция?](#можно-ли-в-функции-python-в-качестве-аргумента-использовать-функцию-если-да-то-как-называется-такая-функция)
* [Назовите парадигмы ООП?](#назовите-парадигмы-ооп)
* [Self (что это, для чего нужен, как и где использовать)](#self-что-это-для-чего-нужен-как-и-где-использовать)
* [Что такое super() и зачем нужен?](#что-такое-super-и-зачем-нужен)
* [Расскажи порядок разрешения методов?](#расскажи-порядок-разрешения-методов)
* [Что такое class methods / static methods?](#что-такое-class-methods--static-methods)
* [Что такое итерация?](#что-такое-итерация)
* [Какие типы данных могут быть ключами словаря?](#какие-типы-данных-могут-быть-ключами-словаря)
* [Может ли изменяться порядок ключей в словаре?](#может-ли-изменяться-порядок-ключей-в-словаре)
* [Какая алгоритмическая сложность у получения значения по ключу из словаря?](#какая-алгоритмическая-сложность-у-получения-значения-по-ключу-из-словаря)
* [Кортеж может быть ключом словаря?](#кортеж-может-быть-ключом-словаря)
* [Какие магические методы должны быть реализованы в в классе, чтоб его можно было использовать в качестве ключа словаря?](#какие-магические-методы-должны-быть-реализованы-в-в-классе-чтоб-его-можно-было-использовать-в-качестве-ключа-словаря)
* [Что такое контекстный менеджер?](#что-такое-контекстный-менеджер)
* [Как реализовать контекстный менеджер? Если ответите через класс, то попросят назвать и другие варианты.](#что-такое-контекстный-менеджер)
* [Что такое GIL?](#что-такое-gil)
* [Чем модуль отличается от пакета?](#чем-модуль-отличается-от-пакета)

---

# ANSWERS

---

**1. Хранилища данных (DWH, Data Lake, архитектура)**

---

## Подходы построения хранилища данных

### 1. Top-down (по Инмону)

#### Суть:

* Подход предполагает **централизованную архитектуру**, при которой в первую очередь создаётся **Enterprise Data Warehouse (EDW)** — единое корпоративное хранилище данных.
* Это хранилище содержит **нормализованные** данные (обычно 3NF), структурированные по предметным областям.

#### Особенности:

* EDW служит **единственным источником правды (Single Source of Truth)**.
* Из EDW создаются **витрины данных (Data Marts)**, уже в денормализованной форме — под нужды конкретных бизнес-пользователей или аналитиков.
* Основной акцент — **качество, консистентность, историчность**.

#### Плюсы:

* Централизованное управление метаданными и качеством данных.
* Удобно масштабировать и сопровождать на уровне всей организации.

#### Минусы:

* Высокая **стоимость и длительность внедрения**.
* Сложность в адаптации к изменяющимся бизнес-требованиям.

---

### 2. Bottom-up (по Кимболлу)

#### Суть:

* Построение хранилища начинается **с витрин данных (Data Marts)**, создаваемых для отдельных бизнес-процессов.
* Позже эти витрины объединяются в **логическое DWH**.

#### Особенности:

* Используется **денормализованная схема**, чаще всего **звезда** (star schema) или **снежинка** (snowflake).
* Данные моделируются вокруг **факт-таблиц** и **измерений**.
* Популярен благодаря своей **простоте и быстрому Time-to-Market**.

#### Плюсы:

* Быстрое получение бизнес-результатов.
* Относительно просто обучить и подключить конечных пользователей.
* Хорошая производительность при аналитических запросах.

#### Минусы:

* При масштабировании и объединении множества витрин возможно **дублирование логики**, **расхождение метрик**.
* Нет единого централизованного источника правды.

---

### 3. Data Vault

#### Суть:

* **Гибридный подход**, сочетающий достоинства Инмона и Кимболла.
* Разделяет структуру на **Hub (ключи сущностей)**, **Link (связи между сущностями)** и **Satellite (атрибуты, историчность)**.

#### Особенности:

* Поддерживает **историчность**, **аудит**, **многоверсионность**.
* Хорошо подходит для **Agile и DevOps** сред.
* Логика бизнес-преобразования вынесена за пределы core-структуры — в **Data Marts**.

#### Плюсы:

* Легко масштабируется и адаптируется под изменения схем источников.
* Строго отделяет бизнес-логику от данных.
* Хорошо подходит для **Big Data и распределённых систем**.

#### Минусы:

* Более **сложная модель**, требует грамотной ETL-реализации.
* Сложность в прямой аналитике без промежуточной агрегации.

---

### 4. Data Lake

#### Суть:

* Хранилище **сырого или полуобработанного** контента в виде файлов, таблиц, изображений и пр.
* Как правило, работает на базе **объектного хранилища**: S3, HDFS, Azure Blob.

#### Особенности:

* Используется в основном для **Big Data** и **Data Science** задач.
* Структура данных может быть **semi-structured** или **unstructured** (JSON, Parquet, Avro и пр.).
* Отложенная обработка (ELT, а не ETL).

#### Плюсы:

* Дешёвое масштабируемое хранилище.
* Гибкость в использовании — можно применять машинное обучение, потоковую обработку и пр.
* Подходит для хранения **огромных объёмов** разнотипных данных.

#### Минусы:

* Отсутствие схемы ведёт к **хаосу и "data swamp"**, если не настроены правила и метаданные.
* Сложнее обеспечить консистентность и управление качеством данных.

---

### 5. Lakehouse

#### Суть:

* Современный гибрид **Data Lake + Data Warehouse**.
* Использует движки вроде **Delta Lake**, **Apache Iceberg**, **Apache Hudi**, которые дают поддержку **ACID**, **time-travel**, **схем**, **индексов** и пр. поверх Data Lake.

#### Особенности:

* Хранение осуществляется в файловой системе, но с возможностями реляционной обработки.
* Работает с теми же инструментами, что и Data Lake (Spark, Presto, Dremio и др.).

#### Плюсы:

* Объединяет гибкость Data Lake с управляемостью DWH.
* Позволяет строить BI-отчёты и Data Science на одних и тех же данных.
* Хорошая производительность и контроль данных.

#### Минусы:

* Пока что менее зрелая технология, требует интеграции нескольких компонентов.
* Не всегда просто настраивается без облачных платформ (Databricks, Snowflake).

---

### 6. Lambda и Kappa архитектуры

#### Lambda Architecture:

* Объединяет **batch processing** (например, Hadoop/Spark) и **stream processing** (Kafka/Storm/Flink).
* Данные сначала обрабатываются в реальном времени (speed layer), а потом — партиями для точности (batch layer).
* Используется при требовании **быстрых и точных данных одновременно**.

#### Kappa Architecture:

* Упрощённая архитектура, в которой **все данные обрабатываются как поток**.
* Нет разделения на batch и stream — единый pipeline.

#### Плюсы:

* Lambda: высокая точность и скорость.
* Kappa: простота архитектуры, лучше подходит для событийных систем.

#### Минусы:

* Lambda: высокая сложность поддержки двух параллельных путей обработки.
* Kappa: сложнее корректировать ошибки в исторических данных.

---

**Заключение**:

Инмон и Кимболл — классические для BI, Data Vault — для гибкости и историчности, Data Lake и Lakehouse — для современных Big Data и ML-задач.

---

## Чем Data Lake отличается от DWH?

### 1. **Тип хранимых данных**

* **DWH (Data Warehouse):**

  * Хранит **структурированные данные** из различных источников, которые предварительно очищаются и трансформируются.
  * Используются реляционные базы данных, таблицы с жёстко заданными схемами.

* **Data Lake:**

  * Может хранить **любой тип данных**: структурированные (таблицы), полуструктурированные (JSON, XML), неструктурированные (изображения, видео, логи).
  * Данные загружаются "как есть", без строгой предварительной обработки (raw format).

---

### 2. **Схема и структура хранения**

* **DWH:**

  * Использует подход **schema-on-write** — данные приводятся к чёткой структуре **до** записи в хранилище.
  * Модель хранения разрабатывается заранее (звезда, снежинка, 3NF).

* **Data Lake:**

  * Использует подход **schema-on-read** — данные приводятся к нужной структуре **только во время чтения**.
  * Возможна работа с данными без заранее заданной схемы.

---

### 3. **Назначение**

* **DWH:**

  * Предназначено для **аналитики и бизнес-отчётности**.
  * Чётко определённые источники данных, высокая точность и надёжность.

* **Data Lake:**

  * Используется для **анализа больших объёмов разнородных данных**, в том числе для **Data Science**, **машинного обучения**, **потоковой обработки**.
  * Часто служит как единое хранилище "сырых" данных.

---

### 4. **Процесс загрузки данных**

* **DWH:**

  * Применяется классическая **ETL (Extract → Transform → Load)** схема: сначала данные очищаются и трансформируются, потом загружаются в хранилище.
* **Data Lake:**

  * Применяется **ELT (Extract → Load → Transform)**: данные сначала загружаются в lake, а потом обрабатываются по мере необходимости.

---

### 5. **Хранилище и технологии**

* **DWH:**

  * Обычно реализовано на **реляционных базах данных** (PostgreSQL, Oracle, Greenplum, Snowflake, MS SQL).
  * Поддерживает SQL-запросы и индексацию.

* **Data Lake:**

  * Строится на **объектных хранилищах** (Amazon S3, HDFS, Azure Blob).
  * Поддерживает работу с файлами (Parquet, ORC, Avro) и распределённую обработку (Spark, Presto, Flink).

---

### 6. **Гибкость и масштабируемость**

* **DWH:**

  * Ограничен типом данных и объёмами. Масштабируемость требует вертикального роста (более мощное железо).
  * Высокие требования к качеству и консистентности.

* **Data Lake:**

  * Гибок, масштабируется горизонтально. Подходит для хранения **петабайтов данных**.
  * Часто используется в **облачных инфраструктурах**.

---

### 7. **Стоимость**

* **DWH:**

  * Дороже в разработке и сопровождении, так как требует проектирования схем, ETL-процессов, инфраструктуры.

* **Data Lake:**

  * Относительно дешевле, особенно при использовании облачных решений. Не требует сложной подготовки данных перед загрузкой.


Оба подхода могут использоваться **совместно**, например: данные сначала собираются в Data Lake, затем после очистки и агрегации загружаются в DWH для бизнес-анализа. Такой гибридный подход особенно популярен в больших компаниях.

---

## Разница между подходами Кимболла и Инмона

Заключается в архитектуре построения хранилищ данных, способе организации данных, приоритетах и применении нормализации. Ниже подробно раскрыты основные различия между двумя подходами.

---

### 1. **Общий подход к построению хранилища**

**Инмон**:

* Считается «отцом корпоративного хранилища данных (EDW)».
* Подход **top-down** — сначала проектируется **централизованное хранилище**, потом на его основе строятся витрины данных для отдельных бизнес-подразделений.
* Основное внимание уделяется **централизованности и согласованности** данных.

**Кимболл**:

* Подход **bottom-up** — сначала создаются **витрины данных (Data Marts)** под конкретные бизнес-задачи, которые затем объединяются в единое логическое хранилище.
* Основной приоритет — **быстрое удовлетворение потребностей бизнеса**, простота реализации.

---

### 2. **Моделирование данных**

**Инмон**:

* Используется **нормализованная структура**, чаще всего **третья нормальная форма (3NF)**.
* Данные хранятся в виде **предметно-ориентированных таблиц**, связанных друг с другом через ключи.
* Цель — устранение избыточности, повышение целостности данных.

**Кимболл**:

* Используются **денормализованные структуры**, в частности **звёздная схема (star schema)** или **снежинка (snowflake schema)**.
* Основные сущности: **факт-таблицы** (события, числовые показатели) и **измерения** (атрибуты сущностей).
* Цель — обеспечить удобство и производительность аналитических запросов.

---

### 3. **Порядок загрузки и обработки данных**

**Инмон**:

* Используется классическая схема **ETL (Extract – Transform – Load)**.
* Данные сначала приводятся к строгой структуре, очищаются, нормализуются, а затем загружаются в хранилище.
* Требует тщательной подготовки и согласования схем.

**Кимболл**:

* Может использовать **ETL** или **ELT**, но основная задача — быстро и удобно представить данные бизнес-пользователям.
* Трансформации выполняются так, чтобы обеспечить удобство построения отчётов и анализа.

---

### 4. **Инфраструктура и масштабируемость**

**Инмон**:

* Предполагает создание **единого корпоративного хранилища**, которое служит универсальным источником данных для всех подразделений.
* Хорошо подходит для **больших организаций** с высокими требованиями к качеству данных и контролю.

**Кимболл**:

* Строится из **наборов независимых витрин**, каждая из которых разрабатывается быстро под конкретную задачу.
* Легче начать внедрение в условиях ограниченных ресурсов или при необходимости быстрого результата.

---

### 5. **Гибкость и сопровождение**

**Инмон**:

* **Менее гибкий**: изменение структуры требует серьёзных доработок в централизованной модели.
* Зато обеспечивает **долгосрочную устойчивость**, согласованность и прозрачность структуры данных.

**Кимболл**:

* **Более гибкий**: легко создавать и модифицировать витрины, адаптируя под новые задачи.
* При масштабировании и объединении витрин может возникнуть **дублирование данных и логики**.

---

### 6. **Пользователи и цели**

**Инмон**:

* Ориентирован на **ИТ-отделы и архитекторов**, строится с учётом стратегических целей и корпоративных требований.
* Часто используется в системах, где важна **аудитность, безопасность, соответствие нормативам**.

**Кимболл**:

* Ориентирован на **бизнес-пользователей и аналитиков**, которым нужны простые отчёты и быстрая аналитика.
* Хорошо подходит для **BI-инструментов** и визуализации данных.

---

### 7. **Примеры применения**

* **Инмон** — крупные организации, банки, телеком, госсектор, где важна высокая целостность и долгосрочная архитектура.
* **Кимболл** — небольшие и средние компании, или команды, которым нужно быстрое внедрение BI.

---

### Заключение

Подход Инмона подходит для создания масштабируемой, надёжной архитектуры, с акцентом на качество и контроль данных. Подход Кимболла — для быстрого внедрения аналитики и адаптивности к изменяющимся требованиям бизнеса.

На практике часто применяются **гибридные подходы**, где корпоративное хранилище проектируется по Инмону, а витрины — по Кимболлу. Это позволяет сочетать централизованность с удобством анализа.

---

## SCD (Slowly Changing Dimensions)

### Что такое SCD?

**SCD (медленно изменяющиеся измерения)** — это справочные таблицы (например, клиенты, продукты, сотрудники), данные в которых изменяются **редко**, но такие изменения необходимо **хранить** и учитывать в аналитике. Например, клиент сменил адрес или должность, и важно понимать, как его поведение или метрики менялись до и после этого события.

---

### Основные типы SCD

#### **SCD Type 0 — неизменяемые измерения**

* Данные в таблице **никогда не изменяются** после загрузки.
* Используется для атрибутов, которые не должны пересматриваться (например, дата рождения).
* Любое изменение источника игнорируется.

**Применение:** паспортные данные, пол, дата рождения.

---

#### **SCD Type 1 — перезапись (overwrite)**

* Изменения **перезаписываются**: старое значение теряется, хранится только актуальное.
* Простой в реализации, но не даёт возможности проанализировать прошлое значение.

**Пример:** клиент сменил город — в таблице просто обновляется значение поля `city`.

**Плюсы:** простая реализация, экономит место.
**Минусы:** невозможно восстановить историю изменений.

---

#### **SCD Type 2 — хранение полной истории изменений**

* Каждое изменение приводит к **созданию новой строки** в таблице.
* Используются специальные поля:

  * `valid_from` / `valid_to` (период действия записи),
  * `is_current` (флаг актуальности),
  * `version` (опционально).

**Пример:** при смене адреса у клиента будет две строки: одна с прошлым адресом, другая — с новым, и только одна из них будет помечена как текущая.

**Плюсы:** можно проводить анализ в ретроспективе, отслеживать, когда и какие изменения происходили.
**Минусы:** большее потребление памяти, усложнённая логика работы.

---

#### **SCD Type 3 — хранение части истории**

* Хранится только **одно предыдущее значение** вместе с текущим (например, `previous_city`, `current_city`).
* Подходит, когда не требуется глубокая история изменений.

**Пример:** для клиента можно хранить текущий и предыдущий адрес, но не более.

**Плюсы:** экономия места.
**Минусы:** ограниченная аналитическая ценность, невозможно отследить более двух состояний.

---

### Другие типы (используемые реже):

#### SCD Type 4 — журнал изменений (Change History Table)

* История хранится **в отдельной таблице**, а основная справочная содержит только актуальные данные.
* Используется для минимизации нагрузки на основную таблицу и для удобной работы с историей.

#### SCD Type 6 — гибрид 1+2+3

* Сочетает сразу несколько стратегий:

  * перезапись текущих значений (как Type 1),
  * хранение истории в виде новых строк (как Type 2),
  * сохранение предыдущего значения в колонке (как Type 3).
* Применяется в системах с высокими требованиями к аналитике.

---

### Зачем нужен SCD?

* Для корректного анализа данных во времени.
* Чтобы избежать искажений в отчётах при изменении справочной информации.
* Для соответствия требованиям аудита и нормативного учёта (например, в банковской или медицинской сфере).

---

### Технические аспекты:

* Важно использовать **бизнес-ключи**, а не surrogate-ключи (primary key), для определения изменений.
* Для Type 2 часто добавляют поля:

  * `surrogate_key` (уникальный ID строки),
  * `valid_from`, `valid_to`,
  * `version`,
  * `is_current`.


---

### Как реализовать SCD Type 2 (на примере клиентов):

Обработка включает три сценария: **вставка новой записи**, **изменение существующей записи** и **обработка удаления**.

#### 1. **Вставка новой записи (insert)**

Если в целевой таблице нет строки с таким `business_key` (например, `customer_id`):

* Вставить новую строку с:

  * `valid_from = now()`
  * `valid_to = NULL`
  * `is_current = true`
  * другими полями, соответствующими входным данным.

---

#### 2. **Изменение существующей записи (update)**

Если запись с `business_key` существует и флаг `is_current = true`, нужно проверить: изменились ли **отслеживаемые** атрибуты (например, адрес, должность и т.д.):

* **Если атрибуты изменились:**

  * Завершить старую запись:

    * `valid_to = now()`
    * `is_current = false`
  * Вставить новую строку:

    * `valid_from = now()`
    * `valid_to = NULL`
    * `is_current = true`
    * с обновлёнными значениями полей.

* **Если изменений нет:**

  * Ничего не делать (данные актуальны, история не нарушается).

---

#### 3. **Удаление записи (delete / логическое удаление)**

Удаления в SCD2 обычно не означают физическое удаление строки, а оформляются как **завершение действия записи**:

* Найти текущую активную запись (`is_current = true`);
* Обновить:

  * `valid_to = now()`
  * `is_current = false`
* (Опционально) добавить логическое поле `is_deleted = true` в новую запись, если требуется отражение удаления.

**Важно:** Если необходимо вести учёт «удалённых» записей (например, клиент ушёл), можно создать новую строку с тем же `business_key`, но с флагом `is_deleted = true`, чтобы сохранялась история.

---

### Как правильно работать с таблицами, если 1я — это просто справочник (например, пользователи) построенный по SCD2, а 2я — это покупки пользователей, и необходимо найти все покупки пользователя с актуальными данными на день покупки.

#### Условия задачи

* **Таблица `users_scd2`** — справочник пользователей, ведётся по SCD Type 2, содержит:

  * `user_id` — бизнес-ключ (natural key);
  * `valid_from` и `valid_to` — диапазон действия версии;
  * `is_current` — флаг актуальности;
  * другие атрибуты (например, `user_city`, `user_status` и т.д.).

* **Таблица `purchases`** — факт-покупки:

  * `user_id` — внешний ключ на пользователя;
  * `purchase_date` — дата покупки;
  * другие атрибуты (сумма, товар и т.д.).

---

#### Цель

Найти все покупки пользователей, при этом — к каждой покупке прикрепить актуальную на **дату покупки** версию пользователя из таблицы `users_scd2`.

---

#### Правильный подход

Для этого выполняется **темпоральное соединение (range join)** по следующему условию:

```sql
purchases.user_id = users_scd2.user_id
AND purchases.purchase_date >= users_scd2.valid_from
AND (purchases.purchase_date < users_scd2.valid_to OR users_scd2.valid_to IS NULL)
```

---

## Пример SQL-запроса

```sql
SELECT
    p.purchase_id,
    p.user_id,
    p.purchase_date,
    p.amount,
    u.user_city,
    u.user_status
FROM
    purchases p
JOIN
    users_scd2 u
    ON p.user_id = u.user_id
   AND p.purchase_date >= u.valid_from
   AND (p.purchase_date < u.valid_to OR u.valid_to IS NULL);
```

---

## Объяснение условий

* `p.user_id = u.user_id` — обычное соединение по бизнес-ключу;
* `p.purchase_date >= u.valid_from` — дата покупки должна быть позже начала действия версии;
* `p.purchase_date < u.valid_to OR u.valid_to IS NULL` — покупка произошла до конца действия версии, или же версия ещё актуальна (в этом случае `valid_to` = `NULL`).

Таким образом, к каждой покупке будет привязана именно **та версия пользователя**, которая была действующей в момент совершения этой покупки.

---

## Слои в хранилище данных

Хранилище данных (Data Warehouse, DWH) строится по **многоуровневой архитектуре**, где каждый слой выполняет свою специфическую задачу и служит промежуточным этапом обработки данных. Это позволяет обеспечить надёжность, масштабируемость и упрощает сопровождение системы.

---

### 1. **Staging Area (или Raw/Buffer Layer)**

**Назначение:** временное хранилище "сырых" данных, загружаемых из источников.
**Характеристики:**

* Данные поступают в том виде, в котором они есть в источниках (CRM, ERP, API и др.);
* Минимальная или отсутствующая обработка;
* Часто хранится только за короткий период времени;
* Используется для анализа отклонений, аудита и повторной загрузки данных при сбоях.

**Примеры данных:** полные выгрузки из таблиц, лог-файлы, JSON от API, бинарные события и т.п.

---

### 2. **ODS (Operational Data Store)**

**ODS (Операционное хранилище данных)** — это слой, предназначенный для хранения операционных (транзакционных) данных, собранных из различных источников. Этот слой обычно:

**Назначение:**

* Быстрое получение оперативной информации (почти в реальном времени);
* Агрегация и нормализация данных;
* Источник для построения витрин или отчётов в текущем моменте времени.

**Характеристики:**

* Структура ближе к нормализованной форме (3NF);
* Обычно хранится только актуальная информация (без истории);
* Может использоваться в операционных отчётах и дэшбордах.

**Пример:** таблица клиентов из разных систем объединяется по бизнес-ключу, чтобы сформировать единое представление "Клиенты".

---

### 3. **DDS (Data Distribution Store / Data Delivery Store / Data Data Store)**

**DDS** — это аналитический слой хранилища, часто служащий **ядром корпоративного DWH**, и включает в себя **измерения (dimensions)** и **факты (facts)**.

**Назначение:**

* Хранение **историзированных** и **обогащённых** данных;
* Формирование единого аналитического контекста;
* Источник для построения витрин данных, BI-отчётов, аналитических панелей.

**Характеристики:**

* Чаще всего денормализованная структура (звезда или снежинка);
* Используются методы SCD (slowly changing dimensions) для ведения истории;
* Обрабатываются бизнес-правила, трансформации, расчёты.

**Подсистемы DDS:**

* **Факт-таблицы (Fact Tables):** содержат метрики, суммы, счета, транзакции и пр.;
* **Измерения (Dimension Tables):** описательные справочники — клиенты, продукты, время, регионы.

---

### 4. **Data Marts (Витрины данных)**

**Назначение:**

* Предоставление данных для конкретных бизнес-пользователей или подразделений;
* Оптимизированы под отчётность и аналитические запросы.

**Характеристики:**

* Могут быть логическими (в рамках DDS) или физическими (отдельные базы/таблицы);
* Настроены под конкретные задачи: отчёт по продажам, маркетинг, логистика;
* Часто имеют упрощённую модель и агрегированные данные.

---

### 5. **Presentation Layer (слой представления)**

**Назначение:**

* Предоставление доступа к данным конечным пользователям, BI-системам, API и другим внешним компонентам.

**Формы представления:**

* SQL-витрины (views, materialized views);
* OLAP-кубы (например, с использованием ClickHouse, SSAS, Vertica и т.д.);
* Доступ через BI-инструменты (Power BI, Tableau, Looker и пр.);
* REST API или GraphQL интерфейсы для интеграции с другими системами.

---

### 6. **Metadata Layer (слой метаданных)**

**Назначение:**

* Хранение описания данных: источники, типы, владельцы, трансформации, история изменений.

**Используется для:**

* Каталогизации и управления качеством данных;
* Поддержки lineage и data governance;
* Интеграции с Data Catalog системами (например, Apache Atlas, DataHub).

---

### Сводная схема слоёв DWH

```plaintext
[ Источники данных ]
        │
        ▼
[ Staging Area (Raw) ]
        │
        ▼
[ ODS — нормализованные и очищенные данные ]
        │
        ▼
[ DDS — аналитическое ядро (факты + измерения) ]
        │
        ▼
[ Data Marts / BI витрины ]
        │
        ▼
[ Presentation Layer — отчёты, BI, API ]
```

---

### Заключение

Хранилище данных строится по многоуровневой архитектуре, где каждый слой играет важную роль:

* **Staging** — буферизация и приём данных;
* **ODS** — нормализация и консолидация оперативной информации;
* **DDS** — ядро аналитики с историей изменений и бизнес-логикой;
* **Data Marts** — ориентация на конкретных потребителей данных;
* **Presentation** — доступ к данным в удобной форме.

---

## Физические JOINы

Физический джойн — это алгоритм, который используется для выполнения операции объединения двух таблиц. Иными словами, это то, что происходит "под капотом", когда вы вызываете join в запросе

Основных алгоритмов всего 3: nested loops, merge join, hash join/hash match.

### Nested loops

Принцип работы уже понятен из названия: каждый элемент внешнего цикла сравнивается с каждым элементом внутреннего.
Алгоритмическая сложность - O(n**2)

```sql
For Each value in pile1
    For Each value in pile2
        If pile1.value = pile2.value
        Return pile1.value, pile2.value
```
 
### Merge join

Для этого алгоритма элементы уже должны быть отсортированы. Тут мы проходимся двумя указателями по элементам и сравниваем их. В конце проходим по оставшимся элементам.

Если не считать сортировку, алгоритмическая сложность - O(n).

```sql
get first row R1 from   input 1
get first row R2 from   input 2

while not at the end   of either input
      begin
          if R1 joins with R2
              begin
                  get next row R2 from input 2
                  return (R1, R2)
              end
          else if R1 < R2
              get next row R1 from input 1
          else
              get next row R2 from input 2
    end
```

### Hash join

Вычисляем хэш для каждого элемента левой таблицы, затем вычисляем хэш у элементов правой таблицы и проверяем его наличие в левой.
Алгоритмическая сложность - O(n).

```sql
// Build phase
FOR each row in BuildTable DO
    Compute hash value for the join key
    Insert row into HashTable based on hash value
END FOR

// Probe phase
FOR each row in ProbeTable DO
    Compute hash value for the join key
    IF hash value exists in HashTable THEN
        Retrieve matching rows from HashTable
        FOR each matching row DO
            Combine rows from ProbeTable and BuildTable
            Add the combined row to the result set
        END FOR
    END IF
END FOR
```

---

### Выбор физического JOIN

После оценки алгоритмической сложности физических джойнов можно прийти к выводу, что выбор hash join является оптимальным решением, однако это далеко не так. Как и во многом в программировании, всегда есть space–time trade-off (компромисс времени и памяти), и выбор оптимального джойна будет зависеть от входных данных.

С выбором джойна в большинстве случаев достаточно хорошо справляется оптимизатор, однако бывают ситуации, когда выбором джойна придется заниматься вам.

#### Условие соединения
Для equi-joins (равенство =, неравенство !=) и non-equi-joins (>, <, >=, <=). Для второго типа подойдет только nested loops.

#### Размер таблиц
Также, конечно, важен размер таблиц. Из-за необходимости многократно проходить по второй таблице в случае с nested loops будет велика цена I/O, в случае merge join будет дорогой сортировка, а в случае hash join может не хватить памяти для хеширования, и часть придется переносить на диск. Хешируется, кстати, меньшая таблица.

Если вы работаете с отсортированными данными, выиграет merge join, а с неотсортированными — hash join.

В случае, когда обе таблицы маленькие, эффективнее может быть nested loops, ведь с merge сортировка может вовсе не окупиться.

#### Индексы и дубликаты
В случае с неиндексированными данными лучше справятся merge и hash join, однако наличие большого количества дубликатов при выборе hash join может повлечь неправильное распределение данных и необходимость обработки коллизий.

---

**9. Python: функции, декораторы, ООП и др.**

---

## Лямбда функция (что это, зачем, где использовать)

**Лямбда-функция** — это **анонимная функция**, то есть функция без имени, которая создаётся с помощью ключевого слова `lambda`.

Синтаксис:

```python
lambda аргументы: выражение
```

Пример:

```python
lambda x, y: x + y
```

Этот код создаёт функцию, которая складывает два аргумента `x` и `y`, но не присваивает ей имя. Чтобы использовать её, её можно вызвать напрямую или присвоить переменной:

```python
add = lambda x, y: x + y
print(add(2, 3))  # 5
```

---

### Зачем нужны лямбда-функции?

Лямбда-функции полезны, когда нужно:

1. **Определить простую функцию на месте**, без необходимости выносить её в отдельную именованную функцию.
2. **Сделать код короче и лаконичнее**, особенно когда функция передаётся как аргумент.
3. **Упростить работу с функциями высшего порядка**, такими как `map`, `filter`, `sorted`, `reduce`.

---

### Где использовать лямбда-функции?

Наиболее частые области применения:

1. **В функции `map()`**

```python
numbers = [1, 2, 3, 4]
squares = list(map(lambda x: x ** 2, numbers))
# [1, 4, 9, 16]
```

2. **В функции `filter()`**

```python
numbers = [1, 2, 3, 4, 5]
evens = list(filter(lambda x: x % 2 == 0, numbers))
# [2, 4]
```

3. **В функции `sorted()` с ключом**

```python
data = [('apple', 2), ('banana', 1), ('cherry', 3)]
sorted_data = sorted(data, key=lambda x: x[1])
# [('banana', 1), ('apple', 2), ('cherry', 3)]
```

---

### Ограничения лямбда-функций

* **Только одно выражение** (нельзя писать несколько инструкций или использовать конструкции вроде `if-else` в виде блоков).
* **Сложность в отладке**, особенно при большом количестве вложенных лямбда-функций.
* **Не всегда читаемо**, особенно для менее опытных разработчиков.

---

### Когда **не стоит** использовать лямбда-функции

* Если функция сложная или многострочная — лучше использовать `def`, чтобы улучшить читаемость.
* Если требуется повторное использование — именованная функция будет понятнее.

---

В Python операторы `==` и `is` используются для **сравнения**, но делают это по-разному и применяются в разных случаях. Вот подробное объяснение различий:

---

## В чем разница "==" и "is"?

### `==` — оператор **сравнения значений**

Оператор `==` проверяет, **равны ли значения** двух объектов, то есть **имеют ли они одинаковое содержимое**.

**Пример**:

```python
a = [1, 2, 3]
b = [1, 2, 3]

print(a == b)  # True — списки имеют одинаковое содержимое
```

Здесь `a` и `b` — это **два разных объекта в памяти**, но их значения совпадают, поэтому `==` возвращает `True`.

---

### `is` — оператор **сравнения идентичности объектов**

Оператор `is` проверяет, **являются ли два объекта на самом деле одним и тем же объектом в памяти**, то есть указывают ли они на **одну и ту же ячейку памяти (один и тот же ID)**.

**Пример**:

```python
a = [1, 2, 3]
b = [1, 2, 3]

print(a is b)  # False — это два разных объекта

c = a
print(a is c)  # True — это один и тот же объект
```

---

### Сравнение в таблице

| Критерий                    | `==` (равенство значений)              | `is` (идентичность объектов)                       |
| --------------------------- | -------------------------------------- | -------------------------------------------------- |
| Что сравнивает              | Содержимое объектов                    | Адреса объектов в памяти (id)                      |
| Может вернуть `True` для... | Разных объектов с одинаковым значением | Только для одного и того же объекта                |
| Пример с числами            | `1000 == 1000 → True`                  | `1000 is 1000 → False` (может быть)                |
| Применение                  | Проверка логического равенства         | Проверка, указывает ли переменная на тот же объект |

---

### Особенности и исключения

1. **Интернирование (interning)**

Python оптимизирует хранение некоторых объектов, таких как **небольшие целые числа** и **строки**, создавая их один раз и повторно используя (интернирование). Поэтому `is` может вернуть `True` даже для на первый взгляд разных переменных.

```python
a = 10
b = 10
print(a is b)  # True — Python использует один и тот же объект

x = 1000
y = 1000
print(x is y)  # False — объекты могут быть разными
```

Поведение зависит от реализации интерпретатора и может отличаться.

2. **Сравнение с `None`**

Сравнение с `None` **всегда** следует делать через `is`, а не `==`.

```python
if value is None:
    ...
```

Потому что `None` — это **одиночный объект**, и `is` проверяет его идентичность корректно.

---

## В чем разница между `func` и `func()`?

Разница между `func` и `func()` в Python принципиальная, и она связана с тем, что в одном случае мы работаем с **ссылкой на функцию**, а в другом — **вызываем эту функцию**.

---

### `func` — это **объект функции** (ссылка на неё)

Когда пишем `func`, без скобок, мы **не вызываем** функцию. Вместо этого мы **ссылаемся на сам объект функции**. Это позволяет, например, передать её как аргумент в другую функцию, сохранить в переменной или вызвать позже.

**Пример**:

```python
def greet():
    return "Hello"

a = greet      # просто ссылка на функцию
print(a)       # <function greet at 0x...>
print(a())     # Hello — вызов через переменную
```

Здесь:

* `a = greet` — сохраняет ссылку на функцию.
* `a()` — вызывает функцию через переменную.

---

### `func()` — это **вызов функции**

Когда пишем `func()`, мы **вызываем** функцию `func`. То есть Python:

1. Выполняет код внутри этой функции,
2. Возвращает результат (если есть оператор `return`),
3. Выполняет побочные эффекты, если они есть (например, печать в консоль, запись в файл и т.д.).

**Пример**:

```python
def greet():
    print("Hello")

greet      # ничего не происходит
greet()    # выводит "Hello"
```

---

### Сравнение:

| Выражение | Что означает      | Что делает                          |
| --------- | ----------------- | ----------------------------------- |
| `func`    | Ссылка на функцию | Ничего не вызывает, можно сохранить |
| `func()`  | Вызов функции     | Запускает функцию                   |

---

### Где важно различие:

1. **Передача функции как аргумента**

```python
def executor(callback):
    return callback()

def say_hi():
    return "Hi"

executor(say_hi)    # передаём функцию — правильно
executor(say_hi())  # передаём результат вызова — ошибка, если результат не функция
```

2. **Создание отложенных вычислений**

```python
actions = [lambda: 2 + 2, lambda: 3 * 3]

for action in actions:
    print(action())  # вызываем каждый элемент списка
```

---

## Назовите изменяемые и неизменяемые объекты (типы).

### Изменяемые объекты (mutable)

Изменяемые объекты — это такие, **состояние которых можно изменить после создания**, не меняя их идентификатор (`id` в памяти).

**Примеры** изменяемых объектов:

| Тип                                    | Пример              | Описание                                     |
| -------------------------------------- | ------------------- | -------------------------------------------- |
| `list`                                 | `[1, 2, 3]`         | Можно добавлять, удалять и изменять элементы |
| `dict`                                 | `{"a": 1}`          | Можно менять значения по ключу               |
| `set`                                  | `{1, 2, 3}`         | Можно добавлять и удалять элементы           |
| `bytearray`                            | `bytearray(b"abc")` | Побайтово изменяемая версия `bytes`          |
| Пользовательские классы (по умолчанию) | `class A: pass`     | Объекты можно менять через атрибуты          |

**Пример**:

```python
lst = [1, 2, 3]
lst[0] = 100
print(lst)  # [100, 2, 3]
```

---

### Неизменяемые объекты (immutable)

Неизменяемые объекты — это такие, **состояние которых нельзя изменить после создания**. Любая попытка изменить их приводит к созданию **нового объекта** в памяти.

**Примеры** неизменяемых объектов:

| Тип         | Пример              | Описание                                       |
| ----------- | ------------------- | ---------------------------------------------- |
| `int`       | `42`                | Любое изменение создаёт новый объект           |
| `float`     | `3.14`              | Аналогично с `int`                             |
| `str`       | `"hello"`           | Изменить символы строки нельзя                 |
| `tuple`     | `(1, 2, 3)`         | Но: может содержать изменяемые элементы внутри |
| `frozenset` | `frozenset([1, 2])` | Неизменяемая версия множества                  |
| `bytes`     | `b"abc"`            | Неизменяемая побайтовая строка                 |
| `bool`      | `True`, `False`     | Подвид `int`, тоже неизменяемый                |
| `NoneType`  | `None`              | Единственный экземпляр                         |

**Пример**:

```python
a = "hello"
print(id(a))          # допустим, 140730
a = a.upper()
print(id(a))          # другой id, т.к. создан новый объект
```

---

### Как проверить, изменяем объект или нет?

Попробуйте изменить его содержимое напрямую или использовать `id()`:

```python
x = (1, 2, 3)
print(id(x))
x = (1, 2, 3, 4)
print(id(x))  # id изменится — новый объект
```

---

### Сравнение изменяемых и неизменяемых:

| Свойство                             | Изменяемые объекты                     | Неизменяемые объекты    |
| ------------------------------------ | -------------------------------------- | ----------------------- |
| Можно менять после создания          | Да                                     | Нет                     |
| `id(obj)` при изменении              | Не меняется                            | Меняется (новый объект) |
| Можно использовать как ключ в `dict` | Нет (если объект сам по себе изменяем) | Да                      |
| Безопасность при многопоточности     | Менее безопасны                        | Более безопасны         |

---

### Вложенные структуры

Некоторые **неизменяемые объекты могут содержать изменяемые внутри**:

```python
t = (1, [2, 3])
t[1][0] = 99
print(t)  # (1, [99, 3]) — tuple сам неизменяем, но содержит изменяемый список
```

---

## Декораторы (что, зачем нужно, как влияет на структуру) + написать свой пример


### Что такое декоратор?

**Декоратор** — это функция, которая **принимает другую функцию как аргумент и возвращает новую функцию**, которая обычно расширяет или изменяет поведение исходной.

Это **структурный паттерн проектирования**, позволяющий оборачивать поведение функций или методов **без изменения их кода**.

На практике это синтаксический сахар для работы с функциями высшего порядка.

---

### Зачем нужны декораторы?

Декораторы позволяют:

* Повторно использовать логику (например, логирование, кеширование, проверка прав).
* Разделять бизнес-логику и инфраструктурный код.
* Следовать принципам чистой архитектуры и **DRY (Don't Repeat Yourself)**.
* Создавать **чистую, читаемую и расширяемую** структуру.

---

### Как работают декораторы?

Если есть функция `@decorator`, это равнозначно:

```python
@decorator
def my_func():
    pass
```

Это то же самое, что:

```python
def my_func():
    pass

my_func = decorator(my_func)
```

То есть декоратор вызывается один раз при определении функции и возвращает новый объект-функцию.

---

### Как влияет на структуру?

1. **Упрощает архитектуру** — например, можно писать обёртки для логирования, измерения времени выполнения, контроля доступа, и применять их к любой функции.

2. **Уменьшает дублирование** — общее поведение (например, валидация, обработка ошибок) пишется один раз и применяется везде.

3. **Изменяет поведение, не трогая код функции** — декоратор работает *снаружи*, не требуя изменить тело декорируемой функции.

---

### Пример собственного декоратора

Допустим, мы хотим логировать вызовы функций:

```python
def log_call(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned {result}")
        return result
    return wrapper
```

Используем декоратор:

```python
@log_call
def add(a, b):
    return a + b

@log_call
def greet(name):
    return f"Hello, {name}!"

# Примеры вызовов
add(2, 3)
greet("Alice")
```

**Результат:**

```
Calling add with args=(2, 3), kwargs={}
add returned 5
Calling greet with args=('Alice',), kwargs={}
greet returned Hello, Alice!
```

---

### Пример с параметрами (декоратор-декоратор)

Иногда нужен декоратор, который сам принимает аргументы:

```python
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def say_hi():
    print("Hi!")

say_hi()  # Выведет "Hi!" трижды
```

---

## Можно ли на одну функцию нацепить несколько декораторов и как они будут считываться?

Да, **в Python можно применять несколько декораторов к одной функции**. Это называется **композиция декораторов**, и она широко используется на практике — например, при логировании, проверке прав доступа, обёртке в кэш и так далее.

---

## Как это работает?

Когда вы пишете несколько декораторов над функцией, они **применяются сверху вниз, но выполняются снизу вверх**.

### Синтаксис:

```python
@decorator1
@decorator2
@decorator3
def my_func():
    pass
```

Это эквивалентно:

```python
def my_func():
    pass

my_func = decorator1(decorator2(decorator3(my_func)))
```

---

## Порядок применения

* **Сначала** применяется `decorator3`, затем его результат оборачивается в `decorator2`, и результат этой обёртки — в `decorator1`.
* **При вызове** функции `my_func()` будет сначала исполняться логика `decorator1`, затем — `decorator2`, и так далее.

---

## Пример

Допустим, у нас есть три декоратора:

```python
def deco1(func):
    def wrapper(*args, **kwargs):
        print("Before deco1")
        result = func(*args, **kwargs)
        print("After deco1")
        return result
    return wrapper

def deco2(func):
    def wrapper(*args, **kwargs):
        print("Before deco2")
        result = func(*args, **kwargs)
        print("After deco2")
        return result
    return wrapper

def deco3(func):
    def wrapper(*args, **kwargs):
        print("Before deco3")
        result = func(*args, **kwargs)
        print("After deco3")
        return result
    return wrapper
```

Применим их к функции:

```python
@deco1
@deco2
@deco3
def say_hello():
    print("Hello")
```

### Вызов:

```python
say_hello()
```

### Результат:

```
Before deco1
Before deco2
Before deco3
Hello
After deco3
After deco2
After deco1
```

---

## Что такое декоратор Шредингера?

Это **функция, которая может быть вызвана как с параметрами, так и без них**, и корректно работает в обоих случаях.

То есть:

```python
@my_decorator
def f():
    pass
```

и

```python
@my_decorator(param=True)
def f():
    pass
```

оба варианта работают. Такая универсальность требует особого способа реализации.

---

### Пример «декоратора Шрёдингера»

```python
import functools

def my_decorator(_func=None, *, param=False):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            print(f"param={param}")
            return func(*args, **kwargs)
        return wrapper

    if _func is None:
        # декоратор вызван с параметрами
        return decorator
    else:
        # декоратор вызван без параметров
        return decorator(_func)
```

### Использование:

```python
@my_decorator
def hello():
    print("Hello")

@my_decorator(param=True)
def world():
    print("World")

hello()
# param=False
# Hello

world()
# param=True
# World
```

---

### Почему это называют «декоратором Шрёдингера»?

Потому что при чтении кода **невозможно заранее точно сказать, является ли `@my_decorator` декоратором с параметрами или нет**, пока не произойдёт «наблюдение» — то есть выполнение кода. Он находится в **суперпозиции состояний**:

* Может быть просто функцией-декоратором;
* Может быть фабрикой декоратора с параметрами.

---

### Для чего используется?

Такие декораторы полезны, когда вы хотите сделать свой декоратор **гибким** — чтобы его можно было применять как:

* `@my_decorator`
* `@my_decorator(param=value)`

И при этом не требовать от пользователя всегда указывать скобки.

---

## Генератор (что, зачем нужно) + написать свой пример

**Генератор** — это специальный тип функции (или выражения) в Python, который **лениво** (по мере запроса) возвращает значения с помощью ключевого слова `yield` вместо `return`.

Вместо того чтобы возвращать весь список сразу, генератор **выдаёт по одному элементу за раз**, сохраняя своё внутреннее состояние между вызовами. Это делает генераторы **эффективными по памяти** и полезными при работе с большими объёмами данных.

---

### Зачем нужны генераторы

1. **Экономия памяти**
   Генераторы не загружают в память всю последовательность — они возвращают элементы по мере запроса.

2. **Быстродействие на больших данных**
   Подход "ленивой" итерации позволяет начать обработку данных до того, как они полностью сформированы.

3. **Читаемость и компактность кода**
   Генераторы позволяют писать более понятный код, особенно для последовательных вычислений.

4. **Удобство для потоковой обработки**
   Используются в пайплайнах обработки данных, логов, стримов и т. д.

---

### Пример: генератор-функция

```python
def count_up_to(max_value):
    count = 1
    while count <= max_value:
        yield count
        count += 1
```

Использование:

```python
for number in count_up_to(5):
    print(number)
```

Результат:

```
1
2
3
4
5
```

---

### Как это работает

Каждый вызов `yield` приостанавливает выполнение функции, и при следующей итерации `for` она **возобновляется с того места**, где остановилась.

---

### Пример: генератор-выражение

Генератор можно записать с помощью выражения, аналогично list comprehension, но в круглых скобках:

```python
squares = (x*x for x in range(5))

for s in squares:
    print(s)
```

Результат:

```
0
1
4
9
16
```

---

### Отличие от обычных функций и списков

| Особенность                   | Обычная функция | Генератор-функция |
| ----------------------------- | --------------- | ----------------- |
| Использует `return`           | Да              | Нет               |
| Использует `yield`            | Нет             | Да                |
| Возвращает сразу все значения | Да              | Нет               |
| Потребляет всю память         | Да              | Нет (ленивый)     |

---

## Как рассчитывается сложность алгоритма? на примере list, tuple

**Асимптотическая сложность алгоритма** (или операции) — это способ описания, **как изменяется время выполнения или потребление памяти при увеличении размера входных данных**. Используется обозначение **"Big O"** — например, `O(1)`, `O(n)`, `O(log n)` и т.д.

---

### Основные обозначения сложности

* **O(1)** — постоянное время, не зависит от размера данных.
* **O(n)** — линейное время, растёт пропорционально размеру входа.
* **O(log n)** — логарифмическое время.
* **O(n²)** — квадратичное время (вложенные циклы).

---

### Сложность операций с `list` и `tuple`

Python `list` и `tuple` — это **последовательности**, но работают по-разному:

* `list` — изменяемая структура, поддерживает добавление, удаление, изменение элементов.
* `tuple` — неизменяемая структура, не поддерживает изменение после создания.

---

### Операции с `list`

| Операция                 | Сложность  | Пояснение                                                     |
| ------------------------ | ---------- | ------------------------------------------------------------- |
| `lst[i]`                 | O(1)       | Доступ по индексу реализован через массив.                    |
| `lst.append(x)`          | O(1)\*     | Амортизированная — иногда требуется перераспределение памяти. |
| `lst.insert(i, x)`       | O(n)       | Сдвиг всех элементов справа от `i`.                           |
| `lst.pop()`              | O(1)       | Удаление последнего элемента.                                 |
| `lst.pop(i)`             | O(n)       | Удаление по индексу требует сдвига остальных.                 |
| `lst.remove(x)`          | O(n)       | Поиск элемента и сдвиг.                                       |
| `lst.index(x)`           | O(n)       | Линейный поиск по элементам.                                  |
| `lst.sort()`             | O(n log n) | Быстрая встроенная сортировка (Timsort).                      |
| `lst.extend([x, y])`     | O(k)       | Добавление `k` элементов.                                     |
| Перебор: `for x in lst:` | O(n)       | Линейная итерация по элементам.                               |

---

### Операции с `tuple`

| Операция                         | Сложность | Пояснение                        |
| -------------------------------- | --------- | -------------------------------- |
| `tpl[i]`                         | O(1)      | Доступ по индексу, как в списке. |
| `tpl.index(x)`                   | O(n)      | Поиск значения.                  |
| `tpl.count(x)`                   | O(n)      | Подсчёт количества вхождений.    |
| Создание новой `tuple` из `list` | O(n)      | Копирование данных из списка.    |
| Перебор: `for x in tpl:`         | O(n)      | Линейная итерация.               |

---

### Почему `tuple` быстрее?

Так как `tuple` **неизменяемы**, они:

* имеют **меньший overhead в памяти**;
* **кэшируются** интерпретатором (в некоторых случаях);
* **быстрее создаются и итерируются**, чем списки.

---

## Как передаются аргументы в функцию?

---

### Виды передачи аргументов в функцию

1. **Позиционные аргументы (positional arguments)**
   Аргументы передаются в том порядке, в котором они объявлены в функции.

2. **Именованные аргументы (keyword arguments)**
   Аргументы передаются по имени параметра, порядок не важен.

3. **Аргументы по умолчанию (default arguments)**
   Параметры функции могут иметь значения по умолчанию, если при вызове они не передаются, используется это значение.

4. **Произвольное количество позиционных аргументов (`*args`)**
   Позволяет передавать функции произвольное число позиционных аргументов, которые собираются в кортеж.

5. **Произвольное количество именованных аргументов (`**kwargs`)**
   Позволяет передавать произвольное число именованных аргументов, которые собираются в словарь.

---

**Подробно о каждом способе**

### 1. Позиционные аргументы

```python
def greet(name, age):
    print(f"Hello, {name}. You are {age} years old.")

greet("Alice", 30)
```

* Значения передаются в том порядке, в котором объявлены параметры.
* Ошибка, если передать меньше или больше аргументов.

---

### 2. Именованные аргументы

```python
greet(age=30, name="Alice")
```

* Параметры явно указываются по имени.
* Позволяет менять порядок аргументов.

---

### 3. Аргументы по умолчанию

```python
def greet(name, age=25):
    print(f"Hello, {name}. You are {age} years old.")

greet("Bob")        # Используется age=25
greet("Bob", 40)    # age=40
```

* Значение параметра используется по умолчанию, если не передано.
* Параметры с дефолтными значениями должны идти после обязательных.

---

### 4. `*args` — произвольное число позиционных аргументов

```python
def sum_all(*args):
    return sum(args)

print(sum_all(1, 2, 3))    # 6
print(sum_all(5))          # 5
```

* Все переданные позиционные аргументы собираются в кортеж `args`.
* Удобно для функций с переменным числом аргументов.

---

### 5. `**kwargs` — произвольное число именованных аргументов

```python
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=30)
```

* Все именованные аргументы собираются в словарь `kwargs`.
* Позволяет передавать дополнительные параметры без их явного объявления.

---

### Как Python передаёт аргументы внутри функции?

* В Python аргументы передаются **по ссылке** на объект, а не копированием значения.
* Для **изменяемых объектов** (например, списков, словарей) это значит, что изменения внутри функции могут повлиять на объект вне её.
* Для **неизменяемых объектов** (например, чисел, строк, кортежей) — изменения внутри функции не влияют на оригинал.

Пример:

```python
def modify_list(lst):
    lst.append(100)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list)  # [1, 2, 3, 100]
```

---

## Функция, которая используется в качестве аргумента, может использовать свои аргументы?

Да, функция, которая передаётся в качестве аргумента другой функции, **может использовать свои собственные аргументы** при вызове. В Python функции являются объектами первого класса, то есть их можно передавать как аргументы, возвращать из других функций и сохранять в переменные.

---

### Как это работает на практике

Рассмотрим пример:

```python
def apply_function(func, x, y):
    return func(x, y)

def multiply(a, b):
    return a * b

result = apply_function(multiply, 3, 4)
print(result)  # Выведет 12
```

Здесь:

* `multiply` — это функция, принимающая два аргумента `a` и `b`.
* Она передаётся как аргумент в функцию `apply_function`.
* Внутри `apply_function` вызывается `func(x, y)`, то есть `multiply(3, 4)`.
* Таким образом, **функция, переданная как аргумент, принимает свои собственные параметры**, которые ей передаются во время вызова.

---

### Возможность передачи аргументов функции-аргументу

Функция-аргумент может иметь любые параметры — позиционные, именованные, с умолчаниями и т. п. Важно, чтобы вызывающая функция передавала нужные аргументы при вызове.

Например:

```python
def executor(func, *args, **kwargs):
    return func(*args, **kwargs)

def greet(name, greeting="Hello"):
    return f"{greeting}, {name}!"

print(executor(greet, "Alice"))               # Hello, Alice!
print(executor(greet, "Bob", greeting="Hi"))  # Hi, Bob!
```

---

### Почему это полезно

* Позволяет писать **универсальные и обобщённые функции**, которые могут принимать разные операции.
* Обеспечивает высокий уровень **гибкости и переиспользования** кода.
* Активно используется в функциональном программировании, коллбэках, обработчиках событий и т. п.

---

## Зачем прописывать тип входящих или выходящих данных в функцию?

Прописание типов входящих и выходящих данных в функции, известное как **аннотация типов** (type hinting), не является обязательным в Python, но имеет важные преимущества и служит нескольким целям.

---

### 1. Улучшение читаемости и понимания кода

Когда в определении функции явно указаны типы параметров и возвращаемого значения, становится сразу понятно, какие данные ожидаются и что функция возвращает. Это облегчает понимание кода другим разработчикам (или самому себе через некоторое время).

Пример:

```python
def add(a: int, b: int) -> int:
    return a + b
```

Такой код сразу показывает, что функция принимает два целых числа и возвращает целое число.

---

### 2. Поддержка статической проверки типов

Инструменты статической типизации (например, **mypy**, **Pyright**) могут анализировать код, находить ошибки типов до запуска программы. Это позволяет выявлять:

* Неправильное использование функций (например, передача строки вместо числа).
* Несоответствие возвращаемых значений заявленному типу.
* Потенциальные ошибки и баги на ранней стадии.

---

## 3. Документирование функции

Типы служат как своего рода **живая документация**, уменьшая необходимость писать дополнительные комментарии и отдельную документацию, особенно если имена параметров недостаточно информативны.

---

## 4. Облегчение рефакторинга и поддержки кода

При изменении кода наличие типовых аннотаций помогает понять, как изменять функции и что можно менять без нарушения логики. Это особенно важно в больших проектах с командной разработкой.

---

## 5. Влияние на выполнение программы

В стандартном Python **аннотации типов никак не влияют на выполнение программы** — они игнорируются интерпретатором. Однако их можно использовать с внешними инструментами для анализа и тестирования.

---

## Пример аннотации типов

```python
from typing import List, Optional

def process_items(items: List[int], flag: Optional[bool] = None) -> int:
    if flag:
        return sum(items)
    else:
        return len(items)
```

---

## Что представляет из себя тип данных Int в Python?

В Python тип данных `int` используется для хранения целых чисел — как положительных, так и отрицательных, включая ноль. Это один из базовых и широко используемых примитивных типов в языке.

---

### Особенности `int` в Python

#### 1. **Произвольная точность**

В отличие от многих языков программирования, где целочисленные типы имеют фиксированный размер (например, 32 или 64 бита), в Python `int` имеет **произвольную точность**. Это значит, что целое число может быть сколь угодно большим (ограничено только объемом доступной памяти).

Пример:

```python
a = 10**100  # Очень большое число
print(a)
```

Python корректно работает с таким числом, не переполняется и не теряет точность.

---

#### 2. **Неизменяемость**

Объекты типа `int` в Python являются **неизменяемыми** (immutable). Это означает, что после создания объекта его значение нельзя изменить. Любые операции с числами создают новый объект.

---

#### 3. **Поддержка всех стандартных арифметических операций**

`int` поддерживает:

* Сложение (`+`)
* Вычитание (`-`)
* Умножение (`*`)
* Целочисленное деление (`//`)
* Деление с плавающей точкой (`/`) — результатом будет `float`
* Остаток от деления (`%`)
* Возведение в степень (`**`)
* Побитовые операции (`&`, `|`, `^`, `~`, `<<`, `>>`)

---

#### 4. **Автоматическое преобразование между типами**

При арифметических операциях с другими типами Python автоматически преобразует `int` в подходящий тип — например, при операции с `float` результат будет `float`.

---

#### 5. **Хранение и производительность**

* Малые числа (обычно от -5 до 256) в Python кэшируются и переиспользуются, что улучшает производительность.
* Большие числа хранятся в виде объектов с массивом цифр, что влияет на скорость операций по сравнению с фиксированными типами в других языках.

---

#### 6. **Создание и преобразование**

* Создать `int` можно с помощью литералов, например `123`, `-456`.
* Можно преобразовать другие типы с помощью функции `int()`, например `int("42")` или `int(3.14)`.

---

### Пример использования `int`

```python
x = 10
y = 3

print(x + y)   # 13
print(x // y)  # 3
print(x / y)   # 3.3333333333333335
print(x ** y)  # 1000

big_num = 10**50
print(big_num)
```

---

## Можно ли в функции Python в качестве аргумента использовать функцию? Если да, то как называется такая функция?

Да, **в Python можно использовать функцию в качестве аргумента другой функции**. Более того, это обычная практика, особенно в функциональном стиле программирования, который Python частично поддерживает.

---

### Как это работает?

В Python **функции являются объектами первого класса (first-class objects)**. Это означает, что их можно:

* Передавать как аргументы в другие функции
* Возвращать из других функций
* Присваивать переменным
* Хранить в структурах данных (например, в списках или словарях)

---

### Как называется такая функция?

Функция, которая **принимает другую функцию как аргумент**, называется **функцией высшего порядка (higher-order function)**.

Также, если функция возвращает другую функцию — она тоже считается функцией высшего порядка.

---

### Пример: передача функции как аргумента

```python
def greet(name):
    return f"Hello, {name}!"

def apply_func(func, value):
    return func(value)

result = apply_func(greet, "Alice")
print(result)  # Hello, Alice!
```

Здесь:

* `greet` — обычная функция, принимающая строку.
* `apply_func` — функция высшего порядка, так как она принимает другую функцию (`func`) и применяет её к значению (`value`).

---

### Пример с использованием встроенной функции `map`

```python
def square(x):
    return x * x

numbers = [1, 2, 3, 4]
squared = list(map(square, numbers))
print(squared)  # [1, 4, 9, 16]
```

`map` — это функция высшего порядка, которая принимает:

* функцию (`square`)
* итерируемый объект (`numbers`)

И применяет функцию к каждому элементу.

---

### Когда это используется?

1. **Передача логики**: позволяет передавать поведение (например, сравнение, фильтрацию, форматирование) как параметр.
2. **Колбэки**: используется во многих библиотеках, где вы передаёте функцию, которая должна выполниться позже (например, обработчики событий).
3. **Функции `map`, `filter`, `sorted`, `reduce` и т. д.**
4. **Декораторы**: принимают функцию, модифицируют её поведение и возвращают новую.

---

## Назовите парадигмы ООП?

В объектно-ориентированном программировании (ООП) существует **несколько ключевых парадигм (или принципов)**, которые определяют его структуру, поведение и подход к организации кода. Эти парадигмы позволяют проектировать программное обеспечение, ориентируясь на **объекты**, которые объединяют **данные** и **поведение**.

Основные парадигмы ООП:

---

### 1. **Абстракция**

**Суть**:
Абстракция позволяет **выделить только значимую информацию** об объекте, скрывая при этом внутреннюю реализацию и ненужные детали.

**Пример**:
Когда вы используете объект `Car`, вы оперируете такими методами, как `start()` или `drive()`, не зная, как устроен двигатель или коробка передач.

**Зачем нужна**:

* Упрощает взаимодействие с объектами
* Делает код более читаемым и понятным
* Снижает связанность

---

### 2. **Инкапсуляция**

**Суть**:
Инкапсуляция — это механизм **ограничения доступа** к внутренним данным объекта и реализации его поведения. Обычно это достигается с помощью **модификаторов доступа** и **свойств**.

**Пример**:
В Python можно обозначить приватные переменные с помощью подчеркивания: `_balance`, и предоставить доступ через методы `get_balance()` и `set_balance()`.

**Зачем нужна**:

* Защищает данные от неконтролируемого изменения
* Позволяет управлять доступом к атрибутам
* Повышает устойчивость и предсказуемость кода

---

### 3. **Наследование**

**Суть**:
Наследование позволяет **создавать новый класс на основе существующего**, унаследовав его свойства и поведение, и при необходимости переопределить или расширить его.

**Пример**:

```python
class Animal:
    def speak(self):
        print("Some sound")

class Dog(Animal):
    def speak(self):
        print("Woof")
```

**Зачем нужно**:

* Позволяет повторно использовать код
* Обеспечивает иерархическую структуру классов
* Упрощает расширение системы

---

### 4. **Полиморфизм**

**Суть**:
Полиморфизм означает возможность **использовать один и тот же интерфейс для разных типов объектов**. Это может быть как **переопределение метода**, так и **использование интерфейсов/абстрактных классов**.

**Пример**:

```python
animals = [Dog(), Cat(), Bird()]
for animal in animals:
    animal.speak()  # У каждого speak будет вести себя по-своему
```

**Зачем нужен**:

* Повышает гибкость и расширяемость кода
* Позволяет писать универсальный код, работающий с разными типами объектов

---

### Заключение

Основные парадигмы объектно-ориентированного программирования:

1. **Абстракция** — скрытие деталей реализации
2. **Инкапсуляция** — защита данных и контроль доступа
3. **Наследование** — повторное использование и расширение поведения
4. **Полиморфизм** — универсальный интерфейс для разных реализаций

---

## Self (что это, для чего нужен, как и где использовать)

`self` — это **ссылка на текущий экземпляр класса** в объектно-ориентированном программировании на Python. Он используется в методах класса для доступа к **свойствам (атрибутам)** и **другим методам** этого же объекта.

---

### 1. Что такое `self`

* `self` — это **не ключевое слово**, а **принятый по соглашению** (convention) параметр первого аргумента в методах экземпляра класса.
* Он указывает на конкретный **объект**, для которого был вызван метод.

---

### 2. Для чего нужен `self`

`self` нужен, чтобы:

* Обращаться к **атрибутам объекта** (например, `self.name`)
* Вызывать **другие методы этого же объекта**
* Хранить **состояние экземпляра класса**
* Разграничивать **локальные переменные** и **данные объекта**

---

### 3. Как и где использовать

`self` используется только в **методах экземпляра** (не в статических и не в методах класса). Вот простой пример:

```python
class Person:
    def __init__(self, name):
        self.name = name  # сохраняем имя в атрибуте объекта

    def say_hello(self):
        print(f"Hello, my name is {self.name}")
```

Пример использования:

```python
p = Person("Alice")
p.say_hello()  # Hello, my name is Alice
```

Здесь:

* `__init__` — это конструктор, в него первым аргументом передаётся `self`
* Через `self.name = name` мы сохраняем значение в объекте
* В `say_hello` мы обращаемся к этому значению через `self.name`

---

### 4. Почему нужно явно писать `self`

В Python нужно **явно указывать `self`**, потому что:

* Это делает связь между методами и атрибутами объекта **прозрачной**
* Python не скрывает механику обращения к объекту (в отличие от некоторых других языков, где `this` встроено неявно)
* Это часть синтаксиса языка

---

### 5. Чем `self` отличается от `this` в других языках

* В Python вы **должны явно указать** `self` в качестве первого параметра в методе.
* В языках вроде Java или C++ `this` не передаётся как параметр — это встроенная переменная, доступная внутри методов по умолчанию.

---

### 6. Пример неправильного использования (без `self`)

```python
class Car:
    def set_color(color):
        self.color = color  # Ошибка: self не определён
```

Такой код вызовет ошибку, потому что `self` не передаётся в метод. Правильно так:

```python
class Car:
    def set_color(self, color):
        self.color = color
```

---

## Что такое super() и зачем нужен?

В Python `super()` — это встроенная функция, которая возвращает **проксирующий объект**, позволяющий **вызывать методы родительского (базового) класса** без необходимости явно указывать его имя.

Это особенно полезно при **наследовании**, когда требуется переопределить методы в дочернем классе, но при этом **сохранить вызов родительской реализации**.

---

### Зачем нужен `super()`

`super()` используется для:

1. **Повторного использования кода базового класса** — вместо дублирования.
2. **Поддержки множественного наследования** — безопасный и корректный способ вызывать методы родителя.
3. **Расширения функциональности метода родителя** — добавление логики до или после вызова метода базового класса.

---

### Пример: вызов конструктора родителя

```python
class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # вызываем __init__ базового класса
        self.breed = breed
```

Здесь:

* `super().__init__(name)` вызывает конструктор `Animal`, чтобы инициализировать `name`.
* Это безопаснее, чем `Animal.__init__(self, name)`, особенно при сложной иерархии классов.

---

### Пример: переопределение метода

```python
class Logger:
    def log(self, message):
        print(f"LOG: {message}")

class TimestampLogger(Logger):
    def log(self, message):
        from datetime import datetime
        timestamped = f"{datetime.now()}: {message}"
        super().log(timestamped)  # вызываем метод из родительского класса
```

---

### Поведение `super()` при множественном наследовании

Когда класс наследует от нескольких родителей, `super()` работает в соответствии с **алгоритмом разрешения порядка методов** (MRO — Method Resolution Order). Это позволяет избегать дублирования вызовов и конфликтов.

Пример:

```python
class A:
    def show(self):
        print("A")

class B(A):
    def show(self):
        print("B")
        super().show()

class C(A):
    def show(self):
        print("C")
        super().show()

class D(B, C):
    def show(self):
        print("D")
        super().show()

d = D()
d.show()
```

Результат:

```
D
B
C
A
```

MRO определяет, в каком порядке вызываются методы родительских классов. Его можно посмотреть так:

```python
print(D.mro())
```

---

### Почему не просто `ParentClass.method(self)`?

Хотя можно вызвать метод родителя явно:

```python
ParentClass.method(self, ...)
```

Но `super()`:

* Работает правильно при **множественном наследовании**
* Следует MRO
* Автоматически адаптируется, если базовый класс изменится

---

### Когда `super()` использовать обязательно

* При наследовании и переопределении методов, особенно `__init__`
* В случаях, когда нужно дополнить поведение родительского метода, а не полностью заменить

---

## Расскажи порядок разрешения методов?

Порядок разрешения методов (Method Resolution Order, **MRO**) — это правило, по которому Python определяет, **в каком порядке искать метод или атрибут** в иерархии наследования классов, когда он вызывается через экземпляр.

Это особенно важно в контексте **множественного наследования**, когда класс наследует от нескольких родительских классов, и один и тот же метод может быть определён в нескольких из них.

---

### Как работает MRO в Python

Python использует алгоритм **C3 Linearization**, который:

1. Учитывает **порядок наследования** (слева направо).
2. Гарантирует, что **дочерний класс всегда проверяется раньше родительского**.
3. Учитывает **иерархию** и не нарушает порядок наследования.

---

### Простой пример (одиночное наследование)

```python
class A:
    def say(self):
        print("A")

class B(A):
    pass

b = B()
b.say()  # Будет искать метод say в B, потом в A
```

MRO: `B → A → object`

---

### Пример с множественным наследованием

```python
class A:
    def say(self):
        print("A")

class B(A):
    def say(self):
        print("B")

class C(A):
    def say(self):
        print("C")

class D(B, C):
    pass

d = D()
d.say()
```

Вывод: `B`

---

#### Почему `B`, а не `C`?

Потому что MRO для класса `D`:

```python
print(D.__mro__)
```

Результат:

```
(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
```

Python идёт по порядку:

* Сначала проверяет `D`
* Затем `B`
* Потом `C`
* Затем `A`
* И только в конце — `object`

---

### Как Python вычисляет MRO (C3 Linearization)

Для класса `D(B, C)`:

* MRO(B) = `[B, A, object]`
* MRO(C) = `[C, A, object]`
* Объединение по алгоритму C3: `[D, B, C, A, object]`

Алгоритм выбирает такой порядок, чтобы:

* Уважать порядок в объявлении (`class D(B, C)`)
* Убедиться, что родительский класс вызывается **после всех его дочерних классов**

---

### Использование `super()` и MRO

Когда вызывается `super()`, Python следует именно **MRO**. Поэтому `super()` корректно работает даже в сложной иерархии классов:

```python
class A:
    def hello(self):
        print("A")

class B(A):
    def hello(self):
        print("B")
        super().hello()

class C(A):
    def hello(self):
        print("C")
        super().hello()

class D(B, C):
    def hello(self):
        print("D")
        super().hello()

D().hello()
```

Результат:

```
D
B
C
A
```

MRO: `[D, B, C, A, object]`

---

### Просмотр порядка разрешения методов

MRO можно посмотреть двумя способами:

```python
print(ClassName.__mro__)
# или
help(ClassName)
```

---

## Что такое class methods / static methods?

В Python, методы класса (`class methods`) и статические методы (`static methods`) — это два способа определить поведение, связанное с классом, но не обязательно с конкретным экземпляром. Они задаются с помощью декораторов `@classmethod` и `@staticmethod`.

---

### 1. **Методы класса (`@classmethod`)**

#### Что это?

Метод класса — это метод, который получает **не экземпляр класса (`self`)**, а **сам класс (`cls`)** в качестве первого аргумента. Это позволяет работать с атрибутами и методами самого класса (например, создавать новые экземпляры).

#### Синтаксис:

```python
class MyClass:
    class_variable = 0

    @classmethod
    def set_class_variable(cls, value):
        cls.class_variable = value
```

#### Особенности:

* Получает доступ к **самому классу** (`cls`), а не к объекту.
* Может изменять **атрибуты класса**, но не конкретного объекта.
* Часто используется как **альтернативный конструктор**.

#### Пример:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def from_string(cls, data_str):
        name, age = data_str.split(',')
        return cls(name, int(age))

p = Person.from_string("Alice,30")
```

В данном случае `from_string` — альтернативный способ создать объект `Person` из строки.

---

### 2. **Статические методы (`@staticmethod`)**

#### Что это?

Статический метод **не принимает ни `self`, ни `cls`**. Это обычная функция, которая просто находится внутри класса **для логической группировки**, но она никак не зависит от самого класса или его экземпляра.

#### Синтаксис:

```python
class MyClass:
    @staticmethod
    def utility(x, y):
        return x + y
```

#### Особенности:

* **Не имеет доступа** ни к экземпляру, ни к классу.
* Используется для **вспомогательных функций**, которые логически связаны с классом.
* Поведение полностью **независимо от состояния** класса и экземпляров.

#### Пример:

```python
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b

result = MathUtils.add(5, 3)
```

Здесь метод `add` не зависит ни от данных класса, ни от его объектов.

---

### Заключение

* Используй **обычные методы**, когда нужно работать с данными конкретного объекта.
* Используй **`@classmethod`**, когда нужно работать с самим классом, а не объектом (например, фабрики).
* Используй **`@staticmethod`**, когда метод никак не зависит от класса и объекта, но логически относится к классу.

---

## Что такое итерация?

**Итерация** — это процесс **последовательного перебора элементов** коллекции (например, списка, строки, множества, словаря) один за другим. В программировании под итерацией чаще всего понимается выполнение набора операций **над каждым элементом** итерируемого объекта.

---

### Что такое итерируемый объект?

Это объект, который **может быть пройден в цикле**, например:

* список (`list`)
* строка (`str`)
* кортеж (`tuple`)
* множество (`set`)
* словарь (`dict`)
* генераторы
* файлы

Такие объекты реализуют специальный метод `__iter__()`, возвращающий **итератор**.

---

### Итератор

Итератор — это объект, который поддерживает метод `__next__()`, возвращающий следующий элемент последовательности. Когда элементов больше нет, возбуждается исключение `StopIteration`.

**Пример "вручную"**:

```python
numbers = [1, 2, 3]
iterator = iter(numbers)

print(next(iterator))  # 1
print(next(iterator))  # 2
print(next(iterator))  # 3
# next(iterator) вызовет StopIteration
```

---

### Итерация в цикле `for`

В Python итерация почти всегда выполняется с помощью цикла `for`, который автоматически вызывает `iter()` и `next()`:

```python
fruits = ["apple", "banana", "cherry"]

for fruit in fruits:
    print(fruit)
```

#### Что происходит "под капотом":

1. Вызов `iter(fruits)` — создаётся итератор.
2. Вызов `next(iterator)` — получаем следующий элемент.
3. Повторяется до исключения `StopIteration`.

---

### Итерация в других контекстах

Итерации можно использовать в:

* генераторах списков:

  ```python
  squares = [x*x for x in range(5)]
  ```
* функциях `map`, `filter`, `zip`, `enumerate`
* написании собственных итераторов через классы
* создании генераторов через `yield`

---

### Зачем нужна итерация?

* Позволяет **обходить** элементы коллекций.
* Используется для **поиска**, **обработки**, **фильтрации** данных.
* Упрощает работу с последовательностями без необходимости ручного доступа по индексам.
* Является основой многих концепций: генераторы, потоки данных, ленивые вычисления.

---

## Какие типы данных могут быть ключами словаря?

В Python **ключами словаря (dict)** могут быть **только неизменяемые (immutable)** и **хешируемые (hashable)** объекты. Это связано с тем, что словарь реализован как хеш-таблица, и ключ должен иметь **фиксированное хеш-значение**, которое не меняется на протяжении его "жизни" в словаре.

---

### Требования к ключу словаря:

1. **Неизменяемость**: ключ должен быть immutable — его содержимое не должно меняться после создания.
2. **Хешируемость**: объект должен реализовывать метод `__hash__()` и быть сравним (`__eq__()`), чтобы словарь мог правильно находить и различать ключи.

---

### Что можно использовать в качестве ключа?

#### Разрешённые типы:

| Тип данных  | Пример                         | Объяснение                           |
| ----------- | ------------------------------ | ------------------------------------ |
| `int`       | `d = {1: "one"}`               | Целые числа неизменяемы и хешируемы  |
| `float`     | `d = {3.14: "pi"}`             | Хешируемы (если не NaN)              |
| `str`       | `d = {"a": 1}`                 | Строки — неизменяемые                |
| `bool`      | `d = {True: "yes"}`            | Логические значения — хешируемы      |
| `tuple`     | `d = {(1, 2): "pair"}`         | Если внутри кортежа только immutable |
| `frozenset` | `d = {frozenset({1,2}): "fs"}` | Неизменяемая версия множества        |
| `bytes`     | `d = {b"key": 123}`            | Неизменяемый тип                     |
| `None`      | `d = {None: "null"}`           | `None` — хешируемый объект           |

---

#### Нельзя использовать:

| Тип данных                          | Причина отказа                                                               |
| ----------------------------------- | ---------------------------------------------------------------------------- |
| `list`                              | Списки изменяемы, нет `__hash__()`                                           |
| `set`                               | Множества изменяемы                                                          |
| `dict`                              | Словари изменяемы                                                            |
| `bytearray`                         | Изменяемый тип                                                               |
| `custom class` (если не хешируемый) | По умолчанию можно, но поведение зависит от реализации `__hash__` и `__eq__` |

Пример ошибки:

```python
my_dict = {[1, 2]: "invalid"}  # TypeError: unhashable type: 'list'
```

---

### Пример использования допустимого ключа:

```python
d = {
    "name": "Alice",
    42: "number",
    (1, 2): "tuple",
    frozenset([1, 2]): "frozen"
}
```

---

### Пользовательские типы в качестве ключей

Если вы создаёте свой класс и хотите использовать его в качестве ключа, он должен реализовать методы:

* `__hash__(self)`
* `__eq__(self, other)`

Пример:

```python
class Key:
    def __init__(self, value):
        self.value = value

    def __hash__(self):
        return hash(self.value)

    def __eq__(self, other):
        return isinstance(other, Key) and self.value == other.value

d = {Key("abc"): "custom object"}
```

---

## Может ли изменяться порядок ключей в словаре?

В современных версиях Python (начиная с **Python 3.7**) **порядок ключей в словаре сохраняется** в том порядке, в котором они были добавлены. Это означает, что если вы вставляете ключи в определённой последовательности, при итерировании по словарю они будут возвращены в этом же порядке.

---

### Пример в Python 3.7+:

```python
data = {}
data["a"] = 1
data["b"] = 2
data["c"] = 3

for key in data:
    print(key)
```

**Результат:**

```
a
b
c
```

Порядок ключей соответствует порядку вставки.

---

### Что влияет на порядок:

* **Добавление новых ключей**: они добавляются в конец словаря.
* **Удаление и повторное добавление ключей**: удалённый ключ теряет своё положение. Повторно добавленный ключ будет в конце.
* **Изменение значения существующего ключа**: не влияет на порядок.

---

## Какая алгоритмическая сложность у получения значения по ключу из словаря?

Получение значения по ключу из словаря в Python имеет **амортизированную временную сложность O(1)** (постоянное время).

---

### Почему O(1)?

Словарь в Python реализован как **хеш-таблица**, где:

* Ключ преобразуется в хеш с помощью встроенной функции `hash()`.
* Хеш используется для определения позиции (индекса) в массиве (внутренней структуре словаря).
* Если по этому индексу сразу находится нужный ключ, значение возвращается немедленно — это и даёт сложность O(1).

---

### Возможные исключения:

Хотя в среднем доступ по ключу выполняется за O(1), в **крайних случаях** (при коллизиях) доступ может деградировать до **O(n)**, где `n` — количество элементов в словаре. Это происходит, если много разных ключей получают одинаковый хеш и попадают в одну "ячейку", образуя цепочку проверок.

Однако:

* Python использует **открытую адресацию** и **разрешение коллизий**, чтобы свести такие случаи к минимуму.
* Система динамически **перехеширует и расширяет** таблицу по мере роста, чтобы сохранить доступ эффективным.

---

## Кортеж может быть ключом словаря?

Да, **кортеж может быть ключом словаря в Python**, но при одном важном условии: **все элементы кортежа должны быть неизменяемыми (immutable)**.

---

### Почему это важно?

Словарь в Python реализован как **хеш-таблица**, а ключи словаря должны быть **хешируемыми** (то есть иметь стабильный `__hash__` и не изменяться после создания). Кортеж сам по себе является **неизменяемым типом данных**, но если он содержит внутри **изменяемые объекты**, то сам кортеж уже становится **нехешируемым**, и использовать его как ключ нельзя.

---

### Примеры

#### Разрешённый случай (все элементы неизменяемы):

```python
d = {
    (1, 2): "a",
    ("x", "y"): "b"
}
print(d[(1, 2)])  # вывод: "a"
```

#### Ошибка: кортеж содержит изменяемый элемент (например, список)

```python
key = (1, [2, 3])  # список внутри
d = {key: "value"}  # TypeError: unhashable type: 'list'
```

---

### Проверка:

```python
hash((1, 2, 3))           # работает
hash((1, [2, 3]))         # вызовет ошибку
```

---

## Какие магические методы должны быть реализованы в в классе, чтоб его можно было использовать в качестве ключа словаря?

Чтобы объект класса можно было использовать в качестве ключа словаря, он должен быть **хешируемым**. Для этого в классе должны быть корректно реализованы два магических метода:

---

### 1. `__hash__(self)`

Этот метод возвращает целое число — **хеш объекта**, который словарь использует для определения позиции в хеш-таблице.
Если `__hash__` не реализован (или возвращает `None`), объект считается **нехешируемым**, и попытка использовать его как ключ вызовет ошибку `TypeError`.

---

### 2. `__eq__(self, other)`

Этот метод определяет, **равны ли два объекта**. Он используется для проверки "а не совпадает ли ключ, который мы ищем, с уже существующим ключом".
Если два объекта имеют одинаковый хеш (`__hash__`), Python вызывает `__eq__`, чтобы сравнить их содержимое.

---

### Важно: согласованность `__hash__` и `__eq__`

Они должны быть **согласованы**, то есть:

* Если `a == b`, то должно быть `hash(a) == hash(b)`
* В противном случае словарь может работать неправильно: например, не найдет значение по ключу или перезапишет "не те" данные.

---

### Пример корректной реализации:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        if not isinstance(other, Person):
            return False
        return self.name == other.name and self.age == other.age

    def __hash__(self):
        return hash((self.name, self.age))


p1 = Person("Alice", 30)
p2 = Person("Alice", 30)

d = {p1: "developer"}
print(d[p2])  # работает, потому что p1 == p2 и hash(p1) == hash(p2)
```

---

### Что произойдёт, если не реализовать `__hash__`?

Если в классе определён `__eq__`, но **не определён `__hash__`**, то Python автоматически сделает `__hash__ = None`, и объект **станет нехешируемым**, даже если он технически неизменяем. Это делается для предотвращения потенциально некорректного поведения.

---

## Что такое контекстный менеджер?

**Контекстный менеджер** — это объект, который управляет **входом в контекст** и **выходом из него**, обеспечивая автоматическое выполнение некоторого кода **до** и **после** блока операций. Он используется, например, для **открытия и закрытия файлов**, **блокировок**, **подключений**, **транзакций**, **временных ресурсов** и т.д.

Контекстные менеджеры используются через конструкцию `with`:

```python
with open("file.txt", "r") as f:
    data = f.read()
```

В этом примере файл автоматически закрывается после выхода из блока `with`, даже если внутри произошла ошибка.

---

### Основные цели:

* Управление ресурсами (файлы, соединения, блокировки);
* Автоматическая очистка или закрытие;
* Обработка исключений в рамках блока;
* Повышение читаемости и надежности кода.

---

### Как работает под капотом?

Контекстный менеджер должен реализовать два магических метода:

#### 1. `__enter__(self)`

* Вызывается **при входе** в блок `with`.
* Возвращаемое значение передаётся в переменную после `as`.

#### 2. `__exit__(self, exc_type, exc_val, exc_tb)`

* Вызывается **при выходе** из блока.
* Аргументы описывают исключение, если оно произошло:

  * `exc_type` — тип исключения;
  * `exc_val` — значение исключения;
  * `exc_tb` — трассировка.

Если `__exit__` возвращает `True`, исключение подавляется, иначе — пробрасывается дальше.

---

### Пример собственного контекстного менеджера:

```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None

    def __enter__(self):
        print("Открытие файла")
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Закрытие файла")
        if self.file:
            self.file.close()

# Использование:
with FileManager("example.txt", "w") as f:
    f.write("Пример")
```

---

### Альтернатива: `contextlib`

Python предоставляет модуль `contextlib`, где можно создавать контекстные менеджеры с использованием декоратора `@contextmanager`:

```python
from contextlib import contextmanager

@contextmanager
def custom_context():
    print("Вход")
    yield "контекст"
    print("Выход")

with custom_context() as val:
    print(f"Работаем с {val}")
```

---

### Примеры встроенных контекстных менеджеров:

* `open(...)` — для файлов;
* `threading.Lock()` — блокировки;
* `decimal.localcontext()` — временные настройки округления;
* `sqlite3.connect(...)` — подключения к БД;
* `contextlib.suppress(Exception)` — подавление исключений.

---

## Что такое GIL?

**GIL (Global Interpreter Lock)** — это глобальная блокировка интерпретатора в реализации Python CPython, которая ограничивает выполнение байт-кода Python в один момент времени только одним потоком.

---

### Что это значит?

* В многопоточных программах на Python, даже если у вас несколько потоков (`threading.Thread`), **выполнение байт-кода Python происходит только в одном потоке одновременно**.
* Другими словами, GIL **сделан для упрощения управления памятью и внутренними структурами интерпретатора**, но при этом ограничивает параллелизм в многопоточных программах.

---

### Почему появился GIL?

* Python использует **счётчик ссылок** для управления памятью.
* Поддерживать правильное обновление этого счётчика в многопоточном окружении сложно и накладно.
* GIL обеспечивает **атомарность операций с памятью**, предотвращая одновременный доступ к внутренним структурам и снижая риск ошибок и повреждения данных.
* Это упрощает реализацию интерпретатора, снижая количество ошибок, связанных с конкуренцией потоков.

---

### Последствия GIL

* На многоядерных системах Python-потоки **не могут эффективно использовать все ядра для выполнения байт-кода одновременно**.
* CPU-интенсивные задачи не получают прироста производительности от многопоточности в CPython.
* Для операций, интенсивно использующих процессор, часто используют:

  * **Многопроцессность** (`multiprocessing`), где каждый процесс имеет свой интерпретатор и GIL.
  * Расширения на C или другие библиотеки, которые **освобождают GIL** при выполнении тяжёлых вычислений (например, NumPy).
* Ввод-вывод (I/O) операции не так сильно страдают из-за GIL, так как в периоды ожидания I/O GIL освобождается, позволяя другим потокам выполняться.

---

### Пример поведения

```python
import threading

def cpu_bound():
    count = 0
    for _ in range(10**7):
        count += 1

threads = []
for i in range(4):
    t = threading.Thread(target=cpu_bound)
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

Хотя создаётся 4 потока, из-за GIL ускорения по сравнению с однопоточным выполнением будет мало или не будет вовсе.

---

### Как обойти ограничения GIL?

* Использовать **многопроцессность**, где каждый процесс имеет свой независимый интерпретатор без общего GIL.
* Использовать библиотеки, которые **освобождают GIL** при выполнении тяжелых вычислений (C-расширения).
* Рассмотреть альтернативные реализации Python, которые не имеют GIL, например:

  * **Jython** (на базе Java)
  * **IronPython** (на базе .NET)
  * **PyPy STM** (экспериментальная поддержка)

Но у них свои ограничения и несовместимости.

---

## Чем модуль отличается от пакета?

В Python понятия **модуль** и **пакет** относятся к организации и структуре кода, но они имеют разные уровни и назначение.

---

### Модуль

* **Модуль** — это **отдельный файл с расширением `.py`**, содержащий код на Python: функции, классы, переменные, а также исполняемые инструкции.
* По сути, модуль — это **единица организации кода**, которую можно импортировать и использовать в других частях программы.
* Имя модуля соответствует имени файла без расширения.

#### Пример модуля

Файл `math_utils.py`:

```python
def add(a, b):
    return a + b

PI = 3.14159
```

Этот модуль можно импортировать в другом файле:

```python
import math_utils

print(math_utils.add(2, 3))
print(math_utils.PI)
```

---

### Пакет

* **Пакет** — это **специальная директория (папка)**, которая содержит один или несколько модулей или вложенных пакетов.
* Папка считается пакетом, если в ней есть файл `__init__.py` (в Python 3.3+ наличие этого файла не обязательно, но часто используется для совместимости).
* Пакеты позволяют **структурировать проект, организуя модули по иерархии папок**.
* Имя пакета используется при импорте для группировки модулей.

#### Пример структуры пакета

```
my_package/
    __init__.py
    module1.py
    module2.py
    sub_package/
        __init__.py
        module3.py
```

Импорт из пакета:

```python
from my_package import module1
from my_package.sub_package import module3
```

---

### Основные отличия

| Характеристика        | Модуль                         | Пакет                                       |
| --------------------- | ------------------------------ | ------------------------------------------- |
| Что это?              | Один файл `.py`                | Директория с модулями и/или пакетами        |
| Наличие `__init__.py` | Не требуется                   | Требуется (рекомендуется для совместимости) |
| Структура             | Плоская                        | Иерархическая                               |
| Использование         | Импортируется напрямую         | Импортируется с указанием пути              |
| Назначение            | Организация кода в одном файле | Организация и группировка множества модулей |

---









---

## Источники

https://t.me/data_interviews
