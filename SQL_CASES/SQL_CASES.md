# SQL_CASES

---

## Понимание JOIN

Дано:
левая таблица
```
Table_1
|co1|col2|col3|
| A | 1  |  4 |
| B | 2  |  3 |
| C | 2  |  2 |
| D | 1  |  5 |
```

правая таблица
```
Table_2
|co1|col2|
| A | z  |
| B | x  |
| C | y  |
```

Что получится в результате следующего запроса:

```sql
SELECT t1.col1, t1.col2, t1.col3, t2.col2
FROM Table_1 t1
    LEFT JOIN Table_2 t2
        ON t1.col1 = t2.col1
            and t1.col2 = 2
            and t1.col3 = 3
```

Логичным может показаться такой (**ошибочный**) вариант:

| B | 2  |  3 | x |


Может показаться, что если в конструкции ON есть предикаты (условия),
```
and t1.col2 = 2
and t2.col3 = 3
```

где с одной из сторон стоит константное значение, то данные условия работают, как фильтр для таблиц. При таком (**неверном**) подходе запрос можно переписать следующим образом:

```sql
SELECT t1.col1, t1.col2, t1.col3, t2.col2
FROM (SELECT * 
      FROM Table_1 
      WHERE t1.col2 = 2
        and t1.col3 = 3
) AS t1
    LEFT JOIN Table_2 t2
        ON t1.col1 = t2.col1
```

Условия в ON — это условия присоединения, а не фильтрации таблиц.

- LEFT JOIN возвращает все строки из левой таблицы — ВСЕГДА!

- Условия в ON ограничивают, с какими строками правой таблицы они смогут совпасть.

- Условие ```t1.col2 = 2 AND t1.col3 = 3``` – это условие на левую таблицу, которое участвует в "фильтрации" со стороны присоединения, но строки из левой таблицы не исчезают из результата.

Именно поэтому - **правильным** результатом запроса будет:

```
| A | 1  |  4 | NULL |
| B | 2  |  3 |   x  |
| C | 2  |  2 | NULL |
| D | 1  |  5 | NULL |
```

---

## Понимание NULL

Дана таблица tbl со следующими данными

```
id
----
1
2
3
4
5
NULL
NULL
```

Вывод запросов:

```
select ... from tbl

1. count(*)    = 7
2. count(1)    = 7
3. count(id)   = 5
4. count(null) = 0
5. min(id)     = 1
6. max(id)     = 5
7. sum(id)     = 15
8. avg(id)     = 3.0
```